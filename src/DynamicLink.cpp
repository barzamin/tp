/* DynamicLink.cpp autogenerated by split.py v0.3 at 2021-01-22 22:42:24.785146 */

#include "global.h"
#include "DynamicLink/DynamicLink.h"
#include "m_Do/m_Do_ext/m_Do_ext.h"
#include "JSystem/JKernel/JKRHeap/JKRHeap.h"
#include "JSystem/JKernel/JKRExpHeap/JKRExpHeap.h"

DynamicModuleControlBase::~DynamicModuleControlBase(void) {
    this->force_unlink();

    DynamicModuleControlBase* prev = this->mPrev;
    if (prev != NULL) {
        prev->mNext = this->mNext;
    }

    DynamicModuleControlBase* next = this->mNext;
    if (next != NULL) {
        next->mPrev = this->mPrev;
    }

    if (/* mFirst */ lbl_80451138 == this) {
        lbl_80451138 = this->mNext;
    }

    if (/* mLast */ lbl_8045113C == this) {
        lbl_8045113C = this->mPrev;
    }

    this->mNext = NULL;
    this->mPrev = NULL;
}

DynamicModuleControlBase::DynamicModuleControlBase() {
    mLinkCount = 0;
    field_0x2 = 0;
    mNext = NULL;

    if (/* mFirst */ lbl_80451138 == NULL) {
        lbl_80451138 = this;
    }

    mPrev = /* mLast */ lbl_8045113C;

    DynamicModuleControlBase* prev = mPrev;
    if (prev != NULL) {
        prev->mNext = this;
    }

    /* mLast */ lbl_8045113C = this;
}

extern "C" {
    void __ct__24DynamicModuleControlBaseFv(void);
    void __dt__24DynamicModuleControlBaseFv(void);
};

bool DynamicModuleControlBase::link() {
    // @todo on debug, does a CheckMainThread

    if (mLinkCount == 0) {
        do_load();
        if (do_link() == 0) {
            return false;
        }

        if (field_0x2 < 0xffff) {
            field_0x2++;
        }
    }

    JUT_ASSERT(mLinkCount != 0xffff); // "mLinkCount < 65535"
    if (mLinkCount < 0xffff) {
        mLinkCount++;
    }

    return true;
}

bool DynamicModuleControlBase::unlink() {
    // @todo on debug, does a CheckMainThread

    if (mLinkCount != 0) {
        mLinkCount--;
        if (mLinkCount == 0) {
            do_unlink();
            do_unload();
        }
    } else {
        // "%08x DynamicModuleControlBase::unlink() mLinkCount id already zero.\n"
        OSReport_Warning(lbl_8039A4A0, this);
    }

    return true;
}

int DynamicModuleControlBase::load_async() {
    if (mLinkCount == 0) {
        return do_load_async();
    }

    return true;
}

bool DynamicModuleControlBase::force_unlink() {
    if (mLinkCount != 0) {
        mLinkCount = 0;
        do_unlink();
    }

    return true;
}

// @todo
asm void DynamicModuleControlBase::dump(void) {
    nofralloc
    #include "DynamicLink/asm/func_80262470.s"
}

DynamicModuleControl::DynamicModuleControl(const char* pModuleName) :
    mResource(NULL), mBss(NULL), field_0x18(0), mModuleName(pModuleName),
    mResourceType(0), field_0x21(0),
    mChecksum(0), mSize(0), mAsyncLoadCallback(NULL)
{
}

// mountCallback__20DynamicModuleControlFPv
// DynamicModuleControl::mountCallback(void*)
#ifdef NONMATCHING
JKRArchive* DynamicModuleControl::mountCallback(void*) {
    JKRExpHeap* heap = mDoExt_getArchiveHeap();

    /* sFileCache */ lbl_80451148 = JKRFileCache::mount(/* "/rel/Final/Release" */ lbl_8039A580, heap, NULL);
    /* sArchive */ lbl_80451144 = JKRArchive::mount(/* "RELS.arc" */ lbl_8039A593, JKRArchive::MOUNT_COMP, heap, JKRArchive::MOUNT_DIRECTION_HEAD);
    if (lbl_80451144 == NULL) {
        OSReport_Warning(lbl_8039A59C, lbl_8039A593);
    }

    return /* sArchive */ lbl_80451144;
}
#else
asm JKRArchive* DynamicModuleControl::mountCallback(void*) {
    nofralloc
#include "DynamicLink/asm/func_802626D0.s"
}
#endif

// initialize__20DynamicModuleControlFv
// DynamicModuleControl::initialize(void)
bool DynamicModuleControl::initialize() {
    /* sFileCache */ lbl_80451148 = NULL;
    /* sArchive */ lbl_80451140 = 0;
    /* sAllocBytes */ lbl_80451144 = NULL;
    mountCallback(NULL);

    return true;
}

extern "C" {
// callback__20DynamicModuleControlFPv
// DynamicModuleControl::callback(void*)
asm void DynamicModuleControl_NS_callback(void) {
    nofralloc
    #include "DynamicLink/asm/func_80262794.s"
}

};

/**
 * Calculates the sum of a #u16 buffer of length \p len
 */
u32 calcSum2(const u16* data, u32 len) {
    u32 accumulator = 0;

    while (len != 0) {
        accumulator += *data;
        len -= 2;
        data++;
    }

    return accumulator;
}

extern "C" {
    void calcSum2__FPCUsUl(void);
}

extern "C" {

// do_load__20DynamicModuleControlFv
// DynamicModuleControl::do_load(void)
asm void func_802627E8(void) {
    nofralloc
    #include "DynamicLink/asm/func_802627E8.s"
}

// do_load_async__20DynamicModuleControlFv
// DynamicModuleControl::do_load_async(void)
asm void func_80262AFC(void) {
    nofralloc
    #include "DynamicLink/asm/func_80262AFC.s"
}

int DynamicModuleControl::do_unload() {
    if (mResource != NULL) {
        JKRFree(mResource);
        mResource = NULL;
    }

    return 1;
}

// dump2__20DynamicModuleControlFv
// DynamicModuleControl::dump2(void)
asm void func_80262C0C(void) {
    nofralloc
    #include "DynamicLink/asm/func_80262C0C.s"
}

// do_link__20DynamicModuleControlFv
// DynamicModuleControl::do_link(void)
asm void func_80262C5C(void) {
    nofralloc
    #include "DynamicLink/asm/func_80262C5C.s"
}

// do_unlink__20DynamicModuleControlFv
// DynamicModuleControl::do_unlink(void)
asm void func_80262F28(void) {
    nofralloc
    #include "DynamicLink/asm/func_80262F28.s"
}

};

// getModuleSize__20DynamicModuleControlCFv
// DynamicModuleControl::getModuleSize(void) const
u32 DynamicModuleControl::getModuleSize() const {
    if (mResource != NULL) {
        s32 size = JKRHeap::getSize(mResource, NULL);
        if (mBss != NULL) {
            //! @bug doesn't actually modify size; i think it's supposed to add to the resource size here
            //! (but it gets added anyway based on the header size lmao)
            /* size += */ JKRHeap::getSize(mBss, NULL);
        }

        return size + mResource->bssSize;
    }

    return 0;
}

// getModuleTypeString__20DynamicModuleControlCFv
// DynamicModuleControl::getModuleTypeString(void) const
const char* DynamicModuleControl::getModuleTypeString() const {
    return lbl_803C34B0[this->mResourceType & 3];
}

extern "C" {
void ModuleProlog() {
    return;
}

void ModuleEpilog(void) {
    return;
}

asm void ModuleUnresolved(void) {
    nofralloc
    #include "DynamicLink/asm/func_80263090.s"
}

typedef void (*ModuleCtor)();
void ModuleConstructorsX(ModuleCtor* ctors) {
    JUT_ASSERT(ctors != NULL);

    while (*ctors != NULL) {
        (*ctors)();
        ctors++;
    }
}

typedef void (*ModuleDtor)();
void ModuleDestructorsX(ModuleDtor* dtors) {
    JUT_ASSERT(dtors != NULL);

    while (*dtors != NULL) {
        (*dtors)();
        dtors++;
    }
}
};


int DynamicModuleControlBase::do_link() {
    return true;
}

int DynamicModuleControlBase::do_load() {
    return true;
}

int DynamicModuleControlBase::do_unload() {
    return true;
}

int DynamicModuleControlBase::do_unlink() {
    return true;
}

int DynamicModuleControlBase::do_load_async() {
    return true;
}

void DynamicModuleControlBase::dump2() {
    return;
}

// getModuleTypeString__24DynamicModuleControlBaseCFv
// DynamicModuleControlBase::getModuleTypeString(void) const
asm const char* DynamicModuleControlBase::getModuleTypeString() const {
    // kinda need string placement for this one tbh
    // or at least some rodata fixes
    nofralloc
    #include "DynamicLink/asm/func_80263200.s"
}

u32 DynamicModuleControlBase::getModuleSize() const {
    return 0;
}


const char* DynamicModuleControl::getModuleName() const {
    return mModuleName;
}

// @todo `__dt__20DynamicModuleControlFv` is getting generated here but should be in c_dylib.o
// it gets pruned by the linker in any case b/c there's no ref to it