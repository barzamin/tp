from typing import Iterable, List
from dataclasses import dataclass
from pathlib import Path, PosixPath
from textwrap import dedent
from loguru import logger
from datetime import datetime
import re
import click
import itertools
from asm import asm, Emittable, Global, Label, Line, BlockComment, Instruction

__version__ = 'v0.1'

def pairwise(iterable):
    "s -> (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = itertools.tee(iterable)
    next(b, None)
    return itertools.zip_longest(a, b)


def function_global_search(lines: List[Line]) -> Iterable[Line]:
    i = 0
    while i < len(lines):
        if isinstance(lines[i].body, Global):
            sym = lines[i].body.symbol
            if isinstance(lines[i+1].body, Label) and lines[i+1].body.symbol == sym:
                yield lines[i]
            i += 2
        else:
            i += 1


def emit_lines(lines: List[Line]) -> str:
    return '\n'.join([line.emit() for line in lines])

def comment_out(line: Emittable) -> Line:
    return BlockComment(line.emit())

@dataclass
class Function:
    name: str
    addr: int
    lines: List[Line]

    @property
    def line_count(self):
        return len(self.lines)
    
    @property
    def filename(self) -> str:
        return f'func_{self.addr:X}.s'
    
    def include_path(self, base: Path) -> str:
        return str(PosixPath(base) / PosixPath(self.filename))

def find_functions(lines: List[Line]) -> Iterable[Function]:
    for func_global_line, next_func_global_line in pairwise(function_global_search(lines)):
        fr = func_global_line.index + 2
        to = next_func_global_line.index-1 if next_func_global_line is not None else -1
        func_lines = lines[fr:to]
        addr = int(func_lines[0].content[0].text.strip().split()[0], 16)

        yield Function(name=func_global_line.body.symbol,
                addr=addr,
                lines=func_lines)

def emit_cxx_asmfn(inc_base: Path, func: Function) -> str:
    return dedent('''\
        asm void {name}(void) {{
            nofralloc
            #include "{inc}"
        }}'''.format(name=func.name,
                     inc=func.include_path(inc_base)))

def emit_cxx_extern_fns(tu_file: str, labels: Iterable[str]) -> str:
    def decl(label):
        return f'void {label}(void);'

    defs = '\n    '.join(decl(label) for label in labels)

    return (f'// additional symbols needed for {tu_file}\n'
            f'// autogenerated by split.py {__version__} at {datetime.utcnow()}\n'
            'extern "C" {\n'
            '    ' + defs
            +'\n}'
    )

def emit_cxx_extern_vars(tu_file: str, labels: Iterable[str]) -> str:
    def decl(label):
        return f'extern u8 {label};'

    return (
        f'// additional symbols needed for {tu_file}\n'
        f'// autogenerated by split.py {__version__} at {datetime.utcnow()}\n'
        + '\n'.join(decl(label) for label in labels)
        + '\n'
    )

@click.command()
@click.argument('src', type=click.File('r'))
@click.argument('cxx_out', type=click.Path(file_okay=True, dir_okay=False))
@click.option('--funcs-out', type=click.Path(file_okay=False, dir_okay=True), default='include/funcs')
@click.option('--s-include-base', type=str, default='funcs')
@click.option('--extern-functions-file', type=click.Path(file_okay=True, dir_okay=False), default='include/functions.h')
@click.option('--extern-variables-file', type=click.Path(file_okay=True, dir_okay=False), default='include/variables.h')
def split(src, cxx_out, funcs_out, s_include_base, extern_functions_file, extern_variables_file):
    funcs_out_dir = Path(funcs_out)
    funcs_out_dir.mkdir(exist_ok=True)

    cxx_out = Path(cxx_out)

    lines = asm.parse(src.read())

    with open(extern_functions_file, 'r') as f:
        extern_funcs_src = f.read()
    with open(extern_variables_file, 'r') as f:
        extern_vars_src = f.read()

    # -- get all defined labels and jump targets
    jumped_labels = set()
    defined_labels = set()

    for line in lines:
        if isinstance(line.body, Label):
            defined_labels.add(line.body.symbol)
        if isinstance(line.body, Instruction):
            if line.body.opcode[0] == 'b' and line.body.operands != []: # branch
                jumped_labels.add(line.body.operands[0]) #jump target

    # -- dump new labels to functions.h

    extern_jump_labels = jumped_labels - defined_labels
    # get rid of stuff already in functions.h. extremely hacky
    funcs_new_labels = set()
    for label in extern_jump_labels:
        if label not in extern_funcs_src:
            logger.info(f'adding extern func {label} to {extern_functions_file}')
            funcs_new_labels.add(label)

    if len(funcs_new_labels) > 0:
        with open(extern_functions_file, 'a') as f:
            f.write('\n\n')
            f.write(emit_cxx_extern_fns(cxx_out.name, funcs_new_labels))

    # -- find everything of the form lbl_[hex] that's in an operand on the RHS of a l* instruction
    #    this is a relatively okay assumption given that any var that's *not* of the form lbl_ has
    #    probably already been renamed and thus is exported in variables.h
    LBL_RE = re.compile(r'lbl_[0-9A-F]+')
    def find_labels_in_operands(operands):
        for operand in operands:
            if match := LBL_RE.search(operand):
                yield match.group()

    loaded_labels = set()
    for line in lines:
        if isinstance(line.body, Instruction) \
                and line.body.opcode[0] == 'l': # load instructions, ish
            loaded_labels |= set(find_labels_in_operands(line.body.operands))

    # -- dump new variable labels to variables.h

    vars_new = set()
    for label in loaded_labels:
        if label not in extern_vars_src:
            logger.info(f'adding extern var {label} to {extern_variables_file}')
            vars_new.add(label)
    
    if len(vars_new) > 0:
        with open(extern_variables_file, 'a') as f:
            f.write('\n\n')
            f.write(emit_cxx_extern_vars(cxx_out.name, vars_new))

    # -- find all defined functions and split them
    functions = list(find_functions(lines))
    for func in functions:

        logger.debug(f'working on function {func.name} @ {func.addr:X} with {func.line_count} lines')

        # comment out .globals
        func.lines = [comment_out(line) if isinstance(line.body, Global) else line for line in func.lines]

        with open(out_path := funcs_out_dir / func.filename, 'w') as f:
            logger.debug(f'emitting {out_path}')
            f.write(emit_lines(func.lines))
        
    # -- write asm stubs to cxx_out (could've done this as part of previous loop but imo this is cleaner)
    logger.info(f'emitting asm stubs to {cxx_out}')
    with open(cxx_out, 'w') as f:
        f.write(f'/* {cxx_out.name} autogenerated by split.py {__version__} at {datetime.utcnow()} */\n\n')
        f.write('#include "global.h"\n\n\n')
        
        for func in functions:
            logger.debug(f'emitting asm stub for {func.name}')
            f.write(emit_cxx_asmfn(s_include_base, func))
            f.write('\n\n')

if __name__ == '__main__':
    split()